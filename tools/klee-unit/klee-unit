#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import sys
from pycparser import c_parser, c_ast, c_generator, parse_file
from typing import Optional

text = r"""
struct some_struct {
    int a;
    double b;
};

typedef int Node, Hash;
int xyz();
void foo(int a, int b) {
}
char foo2(int a, int b[], int c[10], int *d, struct some_struct s);
void bar() {
    int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int b = xyz();
    foo(a, b);
}

extern void *__symbolic();

void klee_unit_test_get_sign()
{
  int x = (*((int *) __symbolic));
  int ret = get_sign(x);
  __watch((void *) (&(ret)));
}
"""


class ParamAdder(c_ast.NodeVisitor):
    def visit_FuncDecl(self, node):
        ty = c_ast.TypeDecl(declname='_hidden',
                            quals=[],
                            align=[],
                            type=c_ast.IdentifierType(['int']))
        newdecl = c_ast.Decl(
            name='_hidden',
            quals=[],
            align=[],
            storage=[],
            funcspec=[],
            type=ty,
            init=None,
            bitsize=None,
            coord=node.coord)
        if node.args:
            node.args.params.append(newdecl)
        else:
            node.args = c_ast.ParamList(params=[newdecl])


def lookup_function(ast: c_ast.FileAST, name: str) -> Optional[c_ast.FuncDecl]:
    """
    Look up a function declaration or definition by name and return the declaration AST node.
    :param ast:
    :param name:
    :return:
    """
    for e in ast.ext:
        if type(e) is c_ast.FuncDef:
            if e.decl.name == name:
                return e.decl.type
        elif type(e) is c_ast.Decl:
            if e.name == name:
                return e.type
    return None


def TypeDecl_by_identifier(name: str, type_id: str) -> c_ast.TypeDecl:
    return c_ast.TypeDecl(
        declname=name,
        quals=[], align=[],
        type=c_ast.IdentifierType(
            names=[type_id]
        )
    )



def generate_driver_func(ast: c_ast.FileAST, uut_name: str) -> c_ast.FileAST:
    uut_decl = lookup_function(ast, uut_name)

    driver_body_item = []
    arg_ids = []

    # Parse arguments
    if uut_decl.args is not None:
        for param in uut_decl.args.params:

            arg_name = param.name
            print(f"Arg {arg_name}:", type(param.type))
            param.type.show()

            if type(param.type) is c_ast.TypeDecl:
                symbolic_stub = c_ast.FuncCall(
                    name=c_ast.ID("SYMBOLIC"),
                    args=c_ast.ExprList(
                        [param.type]  # tricky to generate substitution
                    )
                )
            elif type(param.type) is c_ast.ArrayDecl:
                if param.type.dim is None:
                    dim_stub = c_ast.ID("UNKNOWN_LENGTH")
                else:
                    dim_stub = param.type.dim

                symbolic_stub = c_ast.FuncCall(
                    name=c_ast.ID("SYMBOLIC_ARRAY"),
                    args=c_ast.ExprList(
                        [param.type.type, dim_stub],  # tricky to generate substitution
                    )
                )
            elif type(param.type) is c_ast.PtrDecl:
                symbolic_stub = c_ast.ID("UNKNOWN_POINTER")
            else:
                symbolic_stub = None

            # type_id = param.type.type.names[0]

            # assert param.name == param.type.declname
            arg_name = param.name

            arg_decl = c_ast.Decl(
                name=arg_name,
                quals=param.quals,
                align=param.align,
                storage=param.storage,
                funcspec=param.funcspec,
                type=param.type,
                init=symbolic_stub,
                bitsize=param.bitsize)
            driver_body_item.append(arg_decl)
            # arg_decl.show()

            arg_ids.append(c_ast.ID(arg_name))

    # Parse return type
    ret_type_id = uut_decl.type.type.names[0]
    call_decl = c_ast.FuncCall(name=c_ast.ID(uut_name), args=c_ast.ExprList(arg_ids))
    if ret_type_id == "void":
        driver_body_item.append(call_decl)
    else:
        ret_assign = c_ast.Decl(
            name="ret",
            quals=[], align=[], storage=[], funcspec=[],
            type=TypeDecl_by_identifier("ret", ret_type_id),
            init=call_decl,
            bitsize=None
        )
        driver_body_item.append(ret_assign)

    # Generate test driver function
    driver_name = f"klee_unit_test_{uut_name}"
    driver_body = c_ast.Compound(block_items=driver_body_item)
    driver_decl = c_ast.FuncDef(
        decl=c_ast.Decl(
            name=driver_name,
            quals=[], align=[], storage=[], funcspec=[],
            type=c_ast.FuncDecl(
                args=None,
                type=TypeDecl_by_identifier(driver_name, "void"),
            ),
            init=None, bitsize=None
        ),
        param_decls=None,
        body=driver_body
    )

    # driver_decl.show()
    return c_ast.FileAST(
        [driver_decl]
    )


if __name__ == '__main__':
    parser = c_parser.CParser()
    ast = parser.parse(text)
    print("AST before change:")
    ast.show(offset=2)

    driver_ast = generate_driver_func(ast, "foo2")

    print("\nGenerated driver:")
    generator = c_generator.CGenerator()
    print(generator.visit(driver_ast))
