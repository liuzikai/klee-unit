#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import sys
from pycparser import c_parser, c_ast, c_generator
from typing import Optional

text = r"""
typedef int Node, Hash;
int xyz();
void foo(int a, int b) {
}
char foo2(int a[], int b);
void bar() {
    int a[10] = 0;
    int b = xyz();
    foo(a, b);
}
"""


class ParamAdder(c_ast.NodeVisitor):
    def visit_FuncDecl(self, node):
        ty = c_ast.TypeDecl(declname='_hidden',
                            quals=[],
                            align=[],
                            type=c_ast.IdentifierType(['int']))
        newdecl = c_ast.Decl(
            name='_hidden',
            quals=[],
            align=[],
            storage=[],
            funcspec=[],
            type=ty,
            init=None,
            bitsize=None,
            coord=node.coord)
        if node.args:
            node.args.params.append(newdecl)
        else:
            node.args = c_ast.ParamList(params=[newdecl])


def lookup_function(ast: c_ast.FileAST, name: str) -> Optional[c_ast.FuncDecl]:
    """
    Look up a function declaration or definition by name and return the declaration AST node.
    :param ast:
    :param name:
    :return:
    """
    for e in ast.ext:
        if type(e) is c_ast.FuncDef:
            if e.decl.name == name:
                return e.decl.type
        elif type(e) is c_ast.Decl:
            if e.name == name:
                return e.type
    return None


def TypeDecl_by_identifier(name: str, type_id: str) -> c_ast.TypeDecl:
    return c_ast.TypeDecl(
        declname=name,
        quals=[], align=[],
        type=c_ast.IdentifierType(
            names=[type_id]
        )
    )


def generate_driver_func(ast: c_ast.FileAST, uut_name: str) -> None:
    uut_decl = lookup_function(ast, uut_name)

    driver_body_item = []
    arg_ids = []

    # Parse arguments
    if uut_decl.args is not None:
        for param in uut_decl.args.params:
            type_id = param.type.type.names[0]

            assert param.name == param.type.declname
            arg_name = param.name

            arg_decl = c_ast.Decl(
                name=arg_name,
                quals=param.quals,
                align=param.align,
                storage=param.storage,
                funcspec=param.funcspec,
                type=c_ast.TypeDecl(
                    declname=arg_name,
                    quals=param.type.quals,
                    align=param.type.align,
                    type=c_ast.IdentifierType(
                        names=[type_id]
                    )),
                init=c_ast.Constant(
                    type=type_id,
                    value="42"
                ),
                bitsize=param.bitsize)
            driver_body_item.append(arg_decl)
            # arg_decl.show()

            arg_ids.append(c_ast.ID(arg_name))

    # Parse return type
    ret_type_id = uut_decl.type.type.names[0]
    call_decl = c_ast.FuncCall(name=c_ast.ID(uut_name), args=c_ast.ExprList(arg_ids))
    if ret_type_id == "void":
        driver_body_item.append(call_decl)
    else:
        ret_assign = c_ast.Decl(
            name="ret",
            quals=[], align=[], storage=[], funcspec=[],
            type=TypeDecl_by_identifier("ret", ret_type_id),
            init=call_decl,
            bitsize=None
        )
        driver_body_item.append(ret_assign)

    # Generate test driver function
    driver_name = f"test_{uut_name}"
    driver_body = c_ast.Compound(block_items=driver_body_item)
    driver_decl = c_ast.FuncDef(
        decl=c_ast.Decl(
            name=driver_name,
            quals=[], align=[], storage=[], funcspec=[],
            type=c_ast.FuncDecl(
                args=None,
                type=TypeDecl_by_identifier(driver_name, "void"),
            ),
            init=None, bitsize=None
        ),
        param_decls=None,
        body=driver_body
    )

    # driver_decl.show()
    ast.ext.append(driver_decl)


if __name__ == '__main__':
    parser = c_parser.CParser()
    ast = parser.parse(text)
    print("AST before change:")
    ast.show(offset=2)

    generate_driver_func(ast, "foo2")

    print("\nCode after change:")
    generator = c_generator.CGenerator()
    print(generator.visit(ast))
